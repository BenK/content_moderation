<?php

// $Id: content_moderation.module,v 1.12.2.17 2010/04/18 11:31:29 eugenmayer Exp $

/**
 *
 * @file
 *
 * Copyright (c) 2010 Impressive.media
 * Author: Eugen Mayer
 *
 */

require_once drupal_get_path('module', 'content_moderation') . '/content_moderation.workflow.inc';
require_once drupal_get_path('module', 'content_moderation') . '/content_moderation.trigger.inc';
require_once drupal_get_path('module', 'content_moderation') . '/content_moderation.rules.inc';

/**
 * Implements hook_menu().
 */
function content_moderation_menu() {
  $items = array();
  $items["moderate/%node/%/change"] = array(
      'title' => 'Change moderation state',
      'type' => MENU_CALLBACK,
      'page callback' => 'drupal_get_form',
      'page arguments' => array('content_moderation_change_state_form', 2),
      'access callback' => '_content_moderation_statechange_allowed',
      'access arguments' => array(2)
  );
  $items["node/%node/moderation_history"] = array(
      'title' => 'Moderation history',
      'description' => 'Show the content moderation history.',
      'type' => MENU_LOCAL_TASK,
      'page callback' => '_content_moderation_history',
      'page arguments' => array(1),
      'access callback' => '_content_moderation_access',
      'access arguments' => array('view history', 1),
  );

  $items["node/%node/latest_revision"] = array(
      'page callback' => '_content_moderation_show_latest_revision',
      'page arguments' => array(1),
      'access callback' => '_content_moderation_access',
      'access arguments' => array('view revision', 1),
  );

  // Module settings.
  $items["admin/config/content_moderation"] = array(
      'title' => 'Content moderation',
      'description' => 'Configure content moderation.',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('content_moderation_admin_settings'),
      'access arguments' => array('administer site configuration'),
      'file' => 'content_moderation.admin.inc',
  );
  $items['admin/config/content_moderation/general'] = array(
    'title' => 'General',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -1,
  );

  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function content_moderation_menu_alter(&$items) {
  // we need to get this wrapper in place, as we cant use the nodeapi "prepare" op
  // as module like taxonomy, files and so forth would not fetch the correct versions
  $items['node/%node/edit']['page callback'] = '_content_moderation_node_edit_page';
}


/**
 * Implements hook_block_info().
 */
function content_moderation_block_info() {
  $blocks['moderation']['info'] = t('Content moderation info');
  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function content_moderation_block_view($delta) {
  $function = 'content_moderation_block_view_' . $delta;
  if (function_exists($function)) {
    return $function();
  }
}


/**
 * Implements hook_theme().
 */
function content_moderation_theme() {
  return array(
    'content_moderation_info_block' => array(
      'template' => 'content_moderation_info_block',
      'variables' => array('node' => NULL, 'links' => NULL, 'state' => t('none'), 'live' => NULL, 'revisions_list' => ''),
    ),
    'content_moderation_node_history' => array(
     'variables' => array('history' => array()),
    ),
    'content_moderation_revisions_list' => array(
      'template' => 'content_moderation_revisions_list',
      'variables' => array('revisions' => NULL),
    ),
  );
}

/**
 * Implements hook_help().
 */
function content_moderation_help($path, $arg) {
  switch ($path) {
    case 'admin/help#content_moderation':
      return '<p>' . t("Enables you to moderate the creation of nodes and there further editing. You can have a 'Live version' for all visitors and pending revisions which need to be approved and become the new 'Live Version' then.") . '</p>';
  }
}


/**
 * Implements hook_node_prepare().
 */
function content_moderation_node_prepare($node) {
  // Check to see if this is an existing node
  if (isset($node->nid)) {
    if (_content_moderation_moderate_node_type($node->type)) {
      $live = _content_moderation_live_revision($node->nid);
      // We only need to change the behavior if the current version is not the latest pending version
      if ($live != NULL && $node->vid != $live->vid) {
        drupal_set_message(t('You are now editing the most recent pending revision (@revision) and not the live version!', array('@revision' => $node->vid)), 'warning', FALSE);
      }
    }
  }
}

/**
 * Implements hook_node_presave().
 */
function content_moderation_node_presave($node) {
  // As we cant use $node->old_vid, which always points to the revision
  // on before the current, we need to save the live version ourself
  $node->live = _content_moderation_live_revision($node->nid);

  // We dont need to care about the title if we dont have a approved version yet.
  // Without a approved version, the node revision shown to the use is changed everytime
  // so in that case, content moderation behaves like the classic node edit workflow
  if ($node->live != NULL) {
    $current_title = _content_moderation_get_current_title($node->nid);
    // Lets backup the new title if they differ. We need this as we will set back the title here
    // so modules like pathalias dont break when the node get saved ( path alias will follow the new title otherwise)
    if ($current_title != FALSE && $current_title != $node->title) {
      $node->new_title = $node->title;
      $node->title = $current_title;
    }
    else {
      $node->new_title = FALSE;
    }
  }
}



/**
 * Handles the submit of the node form moderation information
 *
 * @param $form
 * @param $form_state
 */
function content_moderation_node_insert(&$node) {
   content_moderation_node_update($node);
}


/**
 * Implements hook_node_update().
 */
function content_moderation_node_update($node) {
  global $user;
  // Is this content in moderation?
  if (! isset($node->moderation_state_current)) {
    return;
  }

  // Write a history record regardless if there was a moderation state change
  $node_history = array(
    'old_state_name' => $node->moderation_state_current,
    'state_name' => $node->moderation_state_new,
    'nid' => $node->nid,
    'vid' => $node->vid,
    'uid' => $user->uid,
    'stamp' => time()
  );
  drupal_write_record('content_moderation_node_history', $node_history);

  // This revision is now the "current" version
  $record = array(
    'vid' => $node->vid,
    'nid' => $node->nid,
    'hid' => $node_history['hid'],
    'state' => $node->moderation_state_new
  );
  // Delete any existing records
  db_query('DELETE FROM {content_moderation_revision_state} WHERE nid = :nid',
    array(':nid' => $node->nid)
  );
  // Write the new current state
  drupal_write_record('content_moderation_revision_state', $record);

  // If this revision is not the live version and there is a live version, we
  // need to replace *this* vid data in the node table with the actual live vid
  if ($node->moderation_state_new != _content_moderation_live_state()) {
    if ($node->content_moderation['live'] && $live_data = $node->content_moderation['live']) {
      // Now write the live node back to the node table
      $record = array(
        'vid' => $live_data->vid,
        'changed' => $live_data->timestamp,
        'title' => $live_data->title,
        'nid' => $node->nid,
      );
      drupal_write_record('node', $record, 'nid');
      drupal_set_message(t('Your content is now waiting for moderation.'));
    }
  }    
}


/**
 * Implements hook_node_load().
 *
 * Load content moderation history and status on a node.
 */
function content_moderation_node_load($nodes) {
  foreach ($nodes as $node) {
    // Check to make sure that this node type is moderated
    if (_content_moderation_moderate_node_type($node->type)) {
      content_moderation_node_history($node);
    }
  }
}


/**
 * Implements hook_node_view().
 */
function content_moderation_node_view($node, $view_mode = 'full') {
  // We are not showing the node, possible its just a view or something.
  // Dont show all the messages below then.
  if (arg(0) != 'node' || !is_numeric(arg(1)) || !(arg(2) == "") ) {
    return;
  }

  // Does this node have a live version?
  // @TODO what version do we display?
  if (! $node->content_moderation['live']) {
    if (user_access('view content moderation message no live yet')){
      // If this node has no live version yet, notice the user that the content is not valid.
      // Valid reasons are, that the node has been just created and not approved or, that all live
      // revisions have been revoked
      drupal_set_message(t('The content of this document has not been approved yet. '), 'warning' );
    }
  }


  // This is the live node
  if ($node->content_moderation['live']->vid = $node->vid) {

    // Are there pending revisions?
    if ($pending = $node->content_moderation['pending']) {
      foreach ($pending as $revision) {

      }
    }

  }

  // Is this version of the node the current version?
  if ($node->content_moderation['current']->vid == $node->vid) {

  }

return;
  // If we are showing a revision, show the author informations
  if (($live != NULL && $node->vid != $live->vid) && user_access('view content moderation message created by')) {
    // Get username for the revision rather than the original node.
    $revision_author = user_load_multiple($node->revision_uid);
    drupal_set_message(
          t('The revision of this node has been created on @date by !author.',
            array(
             '@date' => format_date($node->revision_timestamp, 'short'),
             '!author' => theme('username', array('account' => $revision_author))
            )
          )
        );
  }
  // If we are showing the live revision of the node and there are any pending version. tell the user about that
  elseif (user_access('view content moderation message pending')) {
    $pending_revisions = _content_moderation_get_latest_revisions($node->nid, 0, NULL);
    $count = count($pending_revisions);

    if ($count == 1) {
      drupal_set_message(t('This document has 1 pending revision', array('@count' => $count)));
    }
    elseif ($count > 1) {
      drupal_set_message(t('This document has @count pending revisions', array('@count' => $count)));
    }
  }
}

/**
 * Implements hook_node_delete().
 */
function content_moderation_node_delete($node) {
  // A node is delete, lets delete the history
  db_query('DELETE FROM {content_moderation_node_history} WHERE nid = :nid', array(':nid' => $node->nid));
  db_query('DELETE FROM {content_moderation_revision_state} WHERE nid = :nid', array(':nid' => $node->nid));
}


/**
 * Implements hook_permission().
 */
function content_moderation_permission() {
  static $rights = FALSE;

  if (! $rights) {
    // This user right is later used for granting the user the approval of pending version
    // making those version "live".
    $states = _content_moderation_states();
    $types = _content_moderation_moderate_node_types();
    $rights = array();
    foreach ($types as $type) {
      foreach ($states as $from_state) {
        $to_states = _content_moderation_next_states($from_state, $type);
        // values are translated
        $to_states = array_keys($to_states);
        foreach ($to_states as $to_state) {
          $rights["moderate $type state $from_state to $to_state"] = array(
            'title' => t('Moderate from state !type to !to_state', array('!type' => $from_state, '!to_state' => $to_state)),
          );
        }
      }
      $rights["view $type moderation history"] = array(
        'title' => t('View !type moderation history', array('!type' => $type)),
        'description' => t('See the complete moderation history of !type content type')
      );

    }

    $rights['view content moderation message'] = array(
      'title' => t('View the moderation messages on a node')
    );

    $rights['view content moderation message pending'] = array(
      'title' => t('View the moderation messages on a node that is pending')
    );

    $rights['view content moderation message not live yet'] = array(
      'title' => t('View the moderation messages on a node that is not live yet')
    );
  }
}


/**
 * Implements hook_form_alter().
 */
function content_moderation_form_node_type_form_alter(&$form, $form_state) {
  // Add JS which handles hiding and showing of these options.
  drupal_add_js(drupal_get_path('module', 'content_moderation') . '/js/content_moderation.js');
  // What states can this node start out in?
  $form['workflow']['node_options']['#options']['moderation'] = t('Enable moderation of revisions');
  $form['workflow']['content_moderation_default_state'] = array(
    '#title' => t('Default moderation state'),
    '#type' => 'select',
    '#options' => content_moderation_states_get(),
    '#default_value' => variable_get('content_moderation_default_state_' . $form['#node_type']->type),
    '#description' => t('Set the default workflow state for this content.
      If a user has additional moderation rights they will be able to change it
      on the node')
  );
  $form['#validate'][] = 'content_moderation_node_type_form_validate';
}


/**
 * Validate the content type form
 */
function content_moderation_node_type_form_validate($from, &$form_state) {
  // Ensure that revisions are enabled if moderation is.
  if ($form_state['values']['node_options']['node_content_moderation'] && ! $form_state['values']['node_options']['revision']) {
    form_set_error('node_options', t('If you chose to moderate this content type,
      you must switch "Create new revision" in the workflow tab on'));
  }
}


/**
 * Implements hook_form_alter().
 *
 * Forcing new reversion and publishing.
 */
function content_moderation_form_alter(&$form, $form_state, $form_id) {
  global $user;

  // This must be a node form and a type that has moderation enabled
  if (! (isset($form['#node_edit_form']) && _content_moderation_moderate_node_type($form['type']['#value']))) {
    return;
  }

  // Set a moderation state even if there is not one defined
  if (isset($form['#node']->content_moderation['current']->state)) {
    $moderation_state = $form['#node']->content_moderation['current']->state;
  }
  else {
    $moderation_state = variable_get('content_moderation_default_state_' . $form['type']['#value']);
  }
  
  // Get all the states *this* user can access. If states is false, this user
  // can not change  the moderation state
  $states = content_moderation_states_next($moderation_state, $user, $form['type']['#value']);
  $current = array($moderation_state => t('Current: !state', array('!state' => $moderation_state)));
  $states = array_merge($current, $states);
  $form['options']['moderation_state_new'] = array(
    '#title' => t('Moderation state'),
    '#type' => 'select',
    '#options' => $states,
    '#default_value' => $moderation_state,
    '#description' => t('Set the moderation state for this content.'),
    '#access' => $states ? TRUE: FALSE,
  );

  // Store the current moderation state
  $form['moderation_state_current'] = array(
    '#type' => 'value',
    '#value' => $moderation_state
  );

  // Move the Revision log under publishing to make things pretty
  $form['options']['log'] = $form['revision_information']['log'];
  $form['options']['log']['#title'] = t('Moderation notes');
  unset($form['revision_information']['log']);

  // Always create new revisions for nodes that are moderated
  $form['revision_information']['revision']['#default_value'] = TRUE;
  // Do not allow users to change the revision status
  $form['revision_information']['#access'] = FALSE;


  $descr = t('You cant choose here, as this content is under moderation. Publishing is forced.');
  if (is_array($form['options']['status']) && variable_get('content_moderation_force_publish', 1)) {
    $form['options']['status']['#disabled'] = TRUE;
    $form['options']['status']['#default_value'] = TRUE;
    $form['options']['status']['#prefix'] = $descr;
    $form['options']['status']['#value'] = TRUE;
  }

  // Add this so we get redirected to the new create revision.
  // Skip this, if thats a new node, as this will happen automatically then
  // Skip this also, if the current node has no approved version then, because content_moderation
  // will behave like the normal node edit workflow then (and not restore the vid)
  if ($form['nid']['#value'] != NULL && _content_moderation_live_revision($form['nid']['#value']) != NULL) {
    $form['buttons']['submit']['#submit'][] = '_content_moderation_submit_node_form';
  }
}


/**
 * Implementation content_moderation_node_history
 * Theming the output of content moderations history table
 */
function theme_content_moderation_node_history($history) {
  $data = array();
  foreach ($history['history'] as $e) {
    $user = user_load($e->uid);
    $state_class = "state_{$e->state_name}";
    // TODO: proper localized date format
    $data[] = array(
      format_date($e->stamp, 'short'),                          // date
      l($user->name, "user/{$user->uid}"),                      // Who changed that state?
      "<span class='$state_class'>" . drupal_ucfirst(t('!old', array('!old' => $e->old_state_name))) . ' -> ' . drupal_ucfirst(t($e->state_name)) . '</span>',              // Transition
      l($e->vid, "node/{$e->nid}/revisions/{$e->vid}/view"),    // revision
      check_plain($e->comment), // comment
    );
  }
  $title = t('Moderation history');
  $title = "<h2>$title</h2>";
  return $title . theme('table', array('header' =>
                array(
                      t('Date'),
                      t('Author'),
                      t('Transition'),
                      t('Revision'),
                      t('Comment'),
                    )
                , 'rows' => $data));
}

/**
 * Needed by the views API
 */
function content_moderation_views_api() {
  return array('api' => 2.0);
}

/**
 * This is our small helper to ensure, that always the newes vid gets edited.
 * The normal node API would edit the vid which is currently in {node} table,
 * But we want to edit the VID which is the most recent one.
 */
function _content_moderation_node_edit_page($node) {
  return node_page_edit($node);

  if (variable_get('content_moderation_moderate_latest_only', 1) === 1) {
    $moderated_revs = _content_moderation_has_moderated_revisions($node->nid);

    // Do not allow state changing of revisions, which are not the latest
    // TODO: Maybe we need a exception for the live state to unapprove it later?
    if (count($moderated_revs) > 0) {
      $none_state = _content_moderation_none_state();
      drupal_set_message(t('You cannot edit the document, as the latest revision is under moderation. Set the revision back to the state "!state" to be able to edit.', array('!state' => $none_state)), 'warning');
      drupal_goto("node/{$node->nid}");
      return FALSE;
    }
  }
  if (_content_moderation_moderate_node_type($node->type)) {
    $vid =  _content_moderation_latest_revision($node->nid);
    // Drupal uses the vid of the node table, not the real latest revision out of node_revisions
    // so we need to determine if it differes. If yes, load the latst revision, as thats our last pending one.

    if ($node->vid != $vid) {
      // We only need to change the behavior if the current version is not the latest pending version.
      $node = node_load($node->nid, $vid);
    }
  }

  return node_page_edit($node);
}

/**
 * Fetch the revision data without using node_load to save some performance.
 */
function _content_moderation_revision_infos($vid) {
  $result = db_query('SELECT * FROM {node_revision} WHERE vid = :vid', array(':vid' => $vid))->fetchObject();
  return $result;
}

/**
 * Calculated the most recent vid of the current node
 */
function _content_moderation_latest_revision($nid) {
  return db_query('SELECT MAX(vid) FROM {node_revision} WHERE nid = :nid', array(':nid' => $nid))->fetchField();
}

/**
 * Generating a history overview of a node.
 */
function _content_moderation_history($node) {
  drupal_add_css(drupal_get_path('module', 'content_moderation') . '/css/content_moderation_history.css');
  $history = _content_moderation_get_history(array('name' => 'nid', 'value' => $node->nid));
  drupal_set_title(t('History'));
  return theme('content_moderation_node_history', array('history' => $history));
}

/**
 * Returning the node object of the live version of the node
 */
function _content_moderation_live_revision($nid) {
  $vid = db_query("SELECT vid FROM {content_moderation_node_history}
    WHERE nid = :nid
      AND state_name = :state
    ORDER BY hid DESC LIMIT 1",
    array(
      ':nid' => $nid,
      ':state' =>  _content_moderation_live_state()
    )
  )->fetchField();

  if (! $vid) {
    return NULL;
  }
  return node_load($nid, $vid);
}

/**
 * Returns the key which represents the live version.
 * Should be later an interface to change the live state
 */
function _content_moderation_live_state() {
  return 'live';
}

/**
 * Returns the key which represents the neutral non moderated version.
 * Should be later an interface to change the live state
 */
function _content_moderation_none_state() {
  return 'none';
}

/**
 * Determine if this content type is set to be moderated
 */
function _content_moderation_moderate_node_type($type) {
  // Is this content even in moderatation?
  if (array_search('moderation', variable_get("node_options_$type", array()))) {
    return TRUE;
  }
  return FALSE;
}

/**
 * List of content types that are moderated
 */
function _content_moderation_moderate_node_types() {
  $types = node_type_get_types();
  $result = array();
  foreach ($types as $type) {
    // Is this content even in moderatation?
    if ( _content_moderation_moderate_node_type($type->type)) {
      $result[] = $type->type;
    }
  }

  return $result;
}

/**
 * Getting nid by vid
 */
function _content_moderation_get_nid($vid) {
  return db_query('SELECT nid FROM {node_revision} WHERE vid = :vid', array(':vid' => $vid))->fetchField();
}

/**
 * Return the proper path to the change-state action
 */
function _content_moderation_change_state_link($vid, $nid) {
  return "moderate/$nid/$vid/change";
}

/**
 * Checking, if the user has the proper rights to change the state of a node, so
 * checking the transition and node type.
 */
function _content_moderation_state_allowed($user, $from_state, $to_state, $node_type) {
  return user_access("content moderation $node_type state $from_state to $to_state");
}

/**
 * Provides a hook where modules can register there access handler.
 *
 * Example:
 *
 * function mymodul_content_moderation_access($op,$node) {
 *  switch($op) {
 *    case 'view history':
 *      return node_acces($op,$node)
 *    break;
 *  }
 * }
 */
function _content_moderation_access($op, $node) {
  if (_content_moderation_moderate_node_type($node->type) === FALSE) {
    return FALSE;
  }

  $modules = module_implements('content_moderation_access');
  if (count($modules) > 0) {
    $grants = module_invoke_all('content_moderation_access', $op, $node);
    $result = TRUE;
    foreach ($grants as $bool) {
      $return = $return && $bool;
    }
    return $result;
  }

  //else the default
  switch ($op) {
    case 'view history':
      return _content_moderation_moderate_node_type($node->type) && user_access("content moderation view {$node->type} moderation history");
      break;
    case 'view revision':
      return node_access('view', $node);
      break;
  }
}

/**
 * Get a number of latest revisions of a node.
 * Use 0 for limit if you want all the revisions
 */
function _content_moderation_get_latest_revisions($nid, $limit = 5, $vid = NULL, $exclude = array()) {
  if ($vid == NULL) {
    if (! $live = _content_moderation_live_revision($nid)) {
      return FALSE;
    }
    $vid = $live->vid;
  }

  if ($limit != 0) {
    $limit = " limit $limit";
  }
  else {
    // limit is zero, so dont use one
    $limit = '';
  }

  $filter = array();
  foreach ($exclude as $v) {
    $filter[] = "nr.vid<>$v";
  }
  if (count($filter) > 0) {
    $filter = join(' AND ', $filter);
    $filter = ' AND ' . $filter;
  }
  else {
    $filter = '';
  }
  // TODO: important, most probably use db_rewrite_sql here
  // if vid is still NULL, we actually dont have a live revision. So we need to count all revisions, even that one
  // which is currently references in the node table.
  if ($vid == NULL) {
    $results = db_query("SELECT nr.*, cmrs.state
      FROM {node_revision} AS nr
      LEFT JOIN {content_moderation_revision_state} AS cmrs
        ON nr.vid = cmrs.vid
      WHERE nr.nid = :nid {$filter}
      ORDER BY nr.vid DESC $limit", array(':nid' => $nid));
  }
  else {
    $results = db_query("SELECT nr.*, cmrs.state
      FROM {node_revision} AS nr
      LEFT JOIN {content_moderation_revision_state} AS cmrs
      ON nr.vid = cmrs.vid
      WHERE nr.nid = :nid
        AND nr.vid > :vid {$filter}
      ORDER BY nr.vid
      DESC $limit", array(':nid' => $nid, ':vid' => $vid)
    );
  }

  $revs = array();
  foreach ($results as $rev) {
    $revs[] = $rev;
  }

  return $revs;
}

function _content_moderation_get_current_viewed_node() {
  // Check the load function to see if a node is being loaded from
  // the menu router
  $router_item = menu_get_item();
  //print_r($router_item);
  // Look for the node load function and then get the argument for the node
  if ($key = array_search('node_load' , $router_item['load_functions'])) {
    // Now we need to find the node
    if (! isset($router_item['map'][$key])) {
      return;
    }

    if (! $node = $router_item['map'][$key]) {
      return NULL;
    }
  }

  // Do we need to load a specific revision of this node?
  if (isset($router_item['map'][2]) && (is_numeric($router_item['map'][2]) && $router_item['map'][3] == 'view')) {
    $vid = $router_item['map'][2];
    $node = node_load($node->nid, $vid);
  }
  return $node;
}

/**
 * Small helper for trigger and rules
 */
function _content_moderation_node_transition_matrix() {
  static $node_state_matrix = array();
  // chaching
  if (count($node_state_matrix) > 0) {
    return $node_state_matrix;
  }
  $states = _content_moderation_states();
  $types = _content_moderation_moderate_node_types();
  foreach ($types as $type) {
    foreach ($states as $from_state) {
      $to_states = _content_moderation_next_states($from_state, $type);
      // Values are translated.
      $to_states = array_keys($to_states);
      foreach ($to_states as $to_state) {
        $node_state_matrix["{$type}_{$from_state}_{$to_state}"] = t("State of node type @type changed from '@from_state' to '@to_state'", array('@type' => $type, '@from_state' => $from_state, '@to_state' => $to_state));
      }
    }
  }
  return $node_state_matrix;
}

/**
 * Checks if the current version is the currently shown as live
 * without beeing approved before (current vid in the {node} table
 */
function _content_moderation_is_not_approved_live($vid) {
  $result = db_query_range('SELECT count(vid) FROM {node} WHERE vid = :vid', 1, 1, array(':vid' => $vid))->fetchField();
  if ($result > 0) {
    return TRUE;
  }
  // else
  return FALSE;
}

function _content_moderation_get_current_title($nid) {
  return db_query('SELECT title FROM {node} WHERE nid = :nid', array(':nid' => $nid))->fetchField();
}

function _content_moderation_show_latest_revision($node) {
  $revisions = _content_moderation_get_latest_revisions($node->nid, 1);
  $node = node_load($node->nid, $revisions[0]->vid);
  menu_set_active_item("node/{$node->nid}/revisions/{$node->vid}/view");
  return node_page_view($node);
}


/**
 * Adds history, current, live, and pending moderation data to a node
 *
 * @param $node
 *   Object, Drupal node object
 */
function content_moderation_node_history(&$node) {
  // Get history
  $results = db_query('SELECT * FROM {content_moderation_node_history}
    WHERE nid = :nid
    ORDER BY hid', array(':nid' => $node->nid)
  );
  foreach ($results as $result) {
    $node->content_moderation['history'][$result->hid] = $result;
  }

  // Get the current state
  $current = db_query('SELECT * FROM {content_moderation_revision_state}
    WHERE nid = :nid',
    array(':nid' => $node->nid))
    ->fetch();
  $node->content_moderation['current'] = $current;

  // If there is a live version, get that
  $live = db_query('SELECT * FROM {content_moderation_node_history}
    WHERE nid = :nid
      AND state_name = :state_name
    ORDER BY stamp DESC',
    array(
      ':nid' => $node->nid,
      ':state_name' => _content_moderation_live_state()))
    ->fetchAll();
  $node->content_moderation['live'] = $live;

  // Are there any revisions that are pending which are not in the live state
  $results = db_query("SELECT * FROM {content_moderation_node_history}
    WHERE nid = :nid
      AND hid >= :hid
      AND state_name <> :live_state
    ORDER BY stamp",
    array(
      ':nid' => $node->nid,
      ':live_state' => _content_moderation_live_state(),
      ':hid' => $node->content_moderation['current']->hid,
    )
  );
  foreach ($results as $rev) {
    $node->content_moderation['pending'][$rev->hid] = $rev;
  }
}




/**
 * Fetch pending revisions of this node
 *
 * @param $nid
 * @return array()
 */
function _content_moderation_has_moderated_revisions($nid) {
  // Get all revisions which are neither in the none nor in the live state
  $results = db_query("SELECT nr.*, cmnh.state_name, cmnh.stamp
    FROM {content_moderation_node_history} AS cmnh
    LEFT JOIN {node_revision} AS nr
      ON nr.vid = cmnh.vid
    WHERE nr.nid = :nid
      AND cmnh.state_name <> :none_state
      AND cmnh.state_name <> :live_state
    ORDER BY cmnh.stamp",
    array(
      ':nid' => $nid,
      ':none_state' => _content_moderation_none_state(),
      ':live_state' => _content_moderation_live_state()
    )
  );

  $revs = array();
  foreach ($results as $rev) {
    $revs[] = $rev;
  }

  return $revs;
}



/**
 * Redirects to the new created revisions
 */
function _content_moderation_submit_node_form($form, &$form_state) {
  $nid = $form['nid']['#value'];
  $form_state['redirect'] = "node/$nid/latest_revision";
}

function _content_moderation_latest_entry_in_history($vid, $state = 'live' ) {
  $result = _content_moderation_get_history(array('name' => 'vid', 'value' => $vid), $state);
  if (is_array($result) && count($result) > 0) {
    return $result[0];
  }
  // else
  return FALSE;
}


/**
 * Displays content moderation information about a specific node
 *
 * @return block array
 */
function content_moderation_block_view_moderation() {
  // Is there a node that is currently being viewed?
  if (! $node = _content_moderation_get_current_viewed_node()) {
    return;
  }
  // No need to show the block if the viewd node is not moderated. Questionable.
  if (! _content_moderation_moderate_node_type($node->type)) {
    return;
  }

  drupal_add_css(drupal_get_path('module', 'content_moderation') . '/css/content_moderation_block.css');

  $pending_revisions = _content_moderation_get_latest_revisions($node->nid, variable_get('content_moderation_pending_count', 5), NULL);
  $revisions_list = theme('content_moderation_revisions_list', array('revisions' => $pending_revisions));

  // All kinds of actions we can do.
  $live = _content_moderation_live_revision($node->nid);
  if ($live != NULL) {
    $links['edit_live'] = "node/{$node->nid}/edit";
    $links['compare'] = "node/{$node->nid}/revisions";
    $links['live_view'] = 'node/' . $live->nid;
    $links['compare_with_live'] = "node/{$node->nid}/revisions/view/{$node->vid}/{$live->vid}";
  }
  $links['edit_state'] = _content_moderation_change_state_link($node->vid, $node->nid);

  // Get the state of the currently view revision
  $state = drupal_ucfirst(_content_moderation_current_state($node->vid));

  $block['subject'] = t("Revisions");
  $block['content'] = theme('content_moderation_info_block', array('node' => $node, 'links' => $links, 'state' => $state, 'live' => $live, 'revisions_list' => $revisions_list));
  $block['cache'] = FALSE;
  return $block;
}


/**
 * Return a list of all states in the system
 */
function content_moderation_states_get() {
  static $states;
  if (! $states) {
    $results = db_query('SELECT * FROM {content_moderation_states}');
    $states = array();
    foreach ($results as $state) {
      $states[$state->name] = $state->name;
    }
  }
  return $states;
}

/**
 * Provides a list of possible next states for this node.
 *
 * @param $current_state
 *   String, current state, optional.
 * @param $account
 *   Object, Drupal user, optional. If this is omitted, all states are returned
 * @param $node_type
 *   String, node type
 * @return array or FALSE
 */
function content_moderation_states_next($current_state = FALSE, $account = FALSE, $node_type = FALSE) {
  // Do we have a current state?
  if (! $current_state) {
    $current_state = _content_moderation_none_state();
  }

  $results = db_query("SELECT to_name AS state
    FROM {content_moderation_transition}
    WHERE from_name = :from_name
      AND (
        ntype = :ntype
        OR ntype = 'all'
      )",
    array(
      ':from_name' => $current_state,
      ':ntype' => $node_type
    )
  );

  $states = array();
  foreach ($results as $state) {
    $states[$state->state] = t($state->state);
  }

  if ($account && $node_type) {
    foreach ($states as $state_name => $value) {
      if (!_content_moderation_state_allowed($account, $current_state, $state_name, $node_type)) {
        unset($states[$state_name]);
      }
    }
  }

  if ($states) {
    return $states;
  }
  return FALSE;
}


/**
 * Utility function to return the node revision information for the specified node
 * 
 * @param $nid 
 */
function content_moderation_node_moderated_live($nid) {
  $vid = db_query("SELECT vid FROM {content_moderation_node_history}
    WHERE state_name = :state
      AND nid = :nid
    ORDER BY stamp DESC",
    array(
      ':state' => _content_moderation_live_state(),
      ':nid' => $nid
    ))
    ->fetchField();

  // Now get the actual revision information
  $revision_data = db_query("SELECT * FROM {node_revision} WHERE nid = :nid AND vid = :vid",
    array(
      ':nid' => $nid,
      ':vid' => $vid
    ))
    ->fetchField();
  
  return $revision_data;
}