<?php

// $Id: content_moderation.module,v 1.12.2.17 2010/04/18 11:31:29 eugenmayer Exp $

# Copyright (c) 2010 Impressive.media
# Author: Eugen Mayer

require_once('content_moderation.workflow.inc');
require_once('content_moderation.trigger.inc');
require_once('content_moderation.rules.inc');



/**
 * Implements hook_block_info.
 */
function content_moderation_block_info() {
  $blocks['moderation_info']['info'] = t('Content moderation info');
  return $blocks;
}


/**
 * Implements hook_block_view.
 */
function content_moderation_block_view($delta) {
  $function = 'content_moderation_block_' . $delta;
  if (function_exists($function)) {
    return $function();
  }
}


/**
 * Implementation of hook_theme
 */
function content_moderation_theme() {
  return array(
    'content_moderation_info_block' => array(
      'template' => 'content_moderation_info_block',
      'variables' => array('arguments' => NULL),
    ),
    'content_moderation_node_history' => array(
     'variables' => array('node' => NULL),

    ),
    'content_moderation_revisions_list' => array(
      'template' => 'content_moderation_revisions_list',
      'variables' => array('revisions' => NULL),
    ),
  );
}

/**
 * Implements hook_help.
 */
function content_moderation_help($path, $arg) {
  switch ($path) {
    case 'admin/help#content_moderation':
      return '<p>' . t("Enables you to moderate the creation of nodes and there further editing. You can have a 'Live version' for all visitors and pending revisions which need to be approved and become the new 'Live Version' then.") . '</p>';
  }
}


/**
 * Implementation of hook_permission().
 */
function content_moderation_permission() {
  static $rights = FALSE;

  if (! $rights) {
    // This user right is later used for granting the user the approval of pending version
    // making those version "live".
    $states = content_moderation_states();
    $types = content_moderation_node_types();
    $rights = array();
    foreach ($types as $type) {
      foreach ($states as $from_state) {
        $to_states = _content_moderation_next_states($from_state, $type);
        // values are translated
        $to_states = array_keys($to_states);
        foreach ($to_states as $to_state) {
          $rights["moderate $type state $from_state to $to_state"] = array(
            'title' => t('Moderate from state !type to !to_state', array('!type' => $from_state, '!to_state' => $to_state)),
          );
        }
      }
      $rights["view $type moderation history"] = array(
        'title' => t('View !type moderation history', array('!type' => $type)),
        'description' => t('See the complete moderation history of !type content type')
      );


    }

    $rights['view content moderation message'] = array(
      'title' => t('View the moderation messages on a node')
    );

    $rights['view content moderation message pending'] = array(
      'title' => t('View the moderation messages on a node that is pending')
    );

    $rights['view content moderation message not live yet'] = array(
      'title' => t('View the moderation messages on a node that is not live yet')
    );
  }

  return $rights;
}


/**
 * Implements hook_node_prepare.
 */
function content_moderation_node_prepare($node) {
  if (content_moderation_node_type_moderated($node->type)) {
    $live =  _content_moderation_live_revision($node->nid);
    // We only need to change the behavior if the current version is not the latest pending version
    if ($live != NULL && $node->vid != $live->vid) {
      drupal_set_message(t('You are now editing the most recent pending revision (@revision) and not the live version!', array('@revision' => $node->vid)), 'warning', false);
    }
  }
}

/**
 * Implements hook_node_presave.
 */
function content_moderation_node_presave($node) {
  // As we cant use $node->old_vid, which always points to the revision
  // on before the current, we need to save the live version ourself
  $node->live = _content_moderation_live_revision($node->nid);

  // We do not need to care about the title if we do not have a approved version yet.
  // Without a approved version, the node revision shown to the use is changed everytime
  // so in that case, content moderation behaves like the classic node edit workflow
  if ($node->live != NULL) {
    $current_title = _content_moderation_get_current_title($node->nid);
    // Lets backup the new title if they differ. We need this as we will set back the title here
    // so modules like pathalias dont break when the node get saved ( path alias will follow the new title otherwise)
    if ($current_title != false && $current_title != $node->title) {
      $node->new_title = $node->title;
      $node->title = $current_title;
    }
    else {
      $node->new_title = false;
    }
  }
}

/**
 * Implements hook_node_update.
 */
function content_moderation_node_update($node) {
  // If we have a current live version (that must not be the current vid entry in {node}!
  // but rather what is in the history table), reset the vid the to live version
  // so that finaly the version presented to the visitor does not change.

  // Without a approved version, the node revision shown to the use is changed everytime
  // so in that case, content moderation behaves like the classic node edit workflow
  if ($node->live != NULL) {
    // Reset the title.
    if ($node->new_title !== false) {
      db_query("UPDATE {node_revision} SET title='%s' WHERE vid=%d", $node->new_title, $node->vid);
    }

    // Reset the revision
    $live_version = _content_moderation_revision_infos($node->live->vid);
    db_query("UPDATE {node} SET vid = %d, changed='%s', title='%s' WHERE nid = %d", $live_version->vid, $live_version->timestamp, $live_version->title, $node->nid);

    drupal_set_message(t('Your content has been saved as a pending version'));
  }
}


/**
 * Implements hook_node_load.
 *
 * @param <type> $node
 */
function content_moderation_node_load($nodes, $form) {
  foreach($nodes as $node) {
    // Check to see if this node type is moderated to reduce overhead
    if (content_moderation_node_type_moderated($node->type)) {
      // Load node history
      content_moderation_node_history($node);
    }
  }
}


/**
 * Implements hook_node_view.
 */
function content_moderation_node_view($node, $view_mode = 'full') {
  // We are not showing the node, possible its just a view or something.
  // Dont show all the messages below then.
  if (arg(0) != 'node' || !is_numeric(arg(1)) || !(arg(2) == "") ) {
    return;
  }

  $live = _content_moderation_live_revision($node->nid);



  // If we are showing the node, but there is no live version yet, give a hard notice.
  if ($live == NULL && user_access('view content moderation message not live yet')) {
    // If this node has no live version yet, notice the user that the content is not valid.
    // Valid reasons are, that the node has been just created and not approved or, that all live
    // revisions have been revoked
    drupal_set_message( t('The content of this document has not been approved and therefore is not valid yet!'), 'warning' );
  }

  // If we are showing a revision, show the author informations
  if (($live != NULL && $node->vid != $live->vid) && user_access('view content moderation message')) {
    // Get username for the revision rather than the original node.
    $revision_author = user_load_multiple($node->revision_uid);
    drupal_set_message(
          t('The revision of this node has been created on @date by !author.',
            array(
             '@date' => format_date($node->revision_timestamp, 'short'),
             '!author' => theme('username', array('account' => $revision_author))
            )
          )
        );
  }
  // If we are showing the live revision of the node and there are any pending version. tell the user about that
  else if (user_access('view content moderation message pending')) {
    $pending_revisions = _content_moderation_get_latest_revisions($node->nid, 0, NULL);
    $count = count($pending_revisions);

    if ($count == 1) {
      drupal_set_message(t('This document has 1 pending revision', array('@count' => $count)));
    }
    else if ($count > 1) {
      drupal_set_message(t('This document has @count pending revisions', array('@count' => $count)));
    }
  }
}

/**
 * Implements hook_node_delete.
 */
function content_moderation_node_delete($node) {
  // A node is delete, lets delete the history
  db_query('DELETE FROM {content_moderation_node_history} WHERE nid=%d', $node->nid);
  db_query('DELETE FROM {content_moderation_revision_state} WHERE nid=%d', $node->nid);
}


/**
 * Access function to see if the node can be moderated
 *
 * Generally check, whether the node-type can be moderated at all
 * and whether the user is allowed to change into that state for that
 * node type.
 */
function content_moderation_access_state_change($node, $vid, $state = NULL) {
  return TRUE;

  // @NOTE I'm not sure if this is needed- should content_moderation
  //       trump Drupal's core permissions?
  /*
  if (node_access('update', $node) === false) {
    return false;
  }
  */



  // Is this content type moderated?
  if (! content_moderation_node_type_moderated($node->type)) {
    drupal_set_message(t('This content type (!type) is not moderated', array('!type' => $node->type)),'error');
    return false;
  }


  /*
  if (variable_get('content_moderation_moderate_latest_only', 1) === 1) {
    $revisions = _content_moderation_get_latest_revisions($nid,1);
    // Do not allow state changing of revisions, which are not the latest

    if (! is_array($revisions) || $revisions[0]->vid != $vid) {
      // return false;
    }
  }

   */

  // Allow any module to deny access
  $state = TRUE;
  drupal_alter('content_moderation_state_change', $state);
  if (! $state) {
    return FALSE;
  }


  return TRUE;
  // Does the user has rights to change to any allowed next states?
  $curstate = _content_moderation_current_state($vid);
  if($state != NULL) {
    return _content_moderation_state_allowed($user, $curstate, $state, $node->type);
  }
  else if(count(_content_moderation_next_states($curstate, $node->type, $user)) > 0) {
    return true;
  }
  //else
  return false;
}


function content_moderation_yaml_theme_layout($layout, $available) {
  global $theme;
  if (module_exists('impressive_media')) {
    $node = _impressive_media_get_cur_node();
  }
  else {
    $node = node_load(arg(1));
  }

  if (!content_moderation_node_type_moderated($node->type)) {
    return;
  }
  // TODO: make this configureable
  return '2col_right_13';
}

/**
 * Add a edit button if we are viewing a live-version or the current latest version
 */
function content_moderation_drupalwiki_menu_alter($tree) {
  if ($tree['meta']['name'] != 'drupalwiki_menu_toolbar') {
    return $tree;
  }

  // Dont show the toolbar if we are editing
  if ( !(arg(0) == 'node' && arg(2) == 'revisions' && is_numeric(arg(3))) ) {
    return $tree;
  }
  $nid = arg(1);
  $vid = arg(3);
  // We fetch the latest 2, as that way we can verify 2 things
  $latest = _content_moderation_get_latest_revisions($nid, 1);
  if (
      (is_array($latest) && count($latest) > 0 && $latest[0]->vid == $vid) ||
      _content_moderation_is_not_approved_live($vid)
  ) {
    $editbtn['link'] = array(
      'title' => t('Edit'),
      'path' => 'node/%/edit',
      'href' => "node/$nid/edit",
      'icon' => icon_get_icon_path('edit', '20'),
      'has_childred' => 0
    );
    $editbtn['below'] = array();
    array_unshift($tree, $editbtn);
  }

  return $tree;
}


/**
 * Implementation of hook_form_alter().
 */
function content_moderation_form_node_type_form_alter(&$form, $form_state) {
  $form['workflow']['node_options']['#options']['node_content_moderation'] = t('Moderate revisions');
  $form['#validate'][] = '_content_moderation_validate_node_type_form';
}

/**
 * Implementation of form_alter.
 * Forcing new reversion and publishing.
 */
function content_moderation_form_alter(&$form, $form_state, $form_id) {
  // Ensure that we have a node type
  if (isset($form['#node']->type) && ! content_moderation_node_type_moderated($form['#node']->type)) {
    // Do not moderate this content type.
    return;
  }

  if ($form['#id'] == 'node-form') {
    // force new revision
    $form['revision_information']['revision']['#prefix'] = t('As this content is in moderation, you cannot choose here. A new revision is always created.');
    $form['revision_information']['revision']['#disabled'] = true;
    $form['revision_information']['revision']['#default_value'] = true;

    $descr = t('You cant choose here, as this content is under moderation. Publishing is forced.');
    if (is_array($form['options']['status']) && variable_get('content_moderation_force_publish', 1)) {
      $form['options']['status']['#disabled'] = true;
      $form['options']['status']['#default_value'] = true;
      $form['options']['status']['#prefix'] = $descr;
      $form['options']['status']['#value'] = true;
    }
    if (module_exists('impressive_media_icombined_access')) {
      $form['custom_options']['status']['#disabled'] = true;
      $form['custom_options']['status']['#default_value'] = true;
      $form['custom_options']['status']['#value'] = true;
      $form['custom_options']['status']['#prefix'] = $descr;
    }
    // Add this so we get redirected to the new create revision.
    // Skip this, if thats a new node, as this will happen automatically then
    // Skip this also, if the current node has no approved version then, because content_moderation
    // will behave like the normal node edit workflow then (and not restore the vid)
    if ($form['nid']['#value'] != NULL && _content_moderation_live_revision($form['nid']['#value']) != NULL) {
      $form['buttons']['submit']['#submit'][] = '_content_moderation_submit_node_form';
    }
  }
}


/**
 * Needed by the views API
 */
function content_moderation_views_api() {
  return array('api' => 2.0);
}

/**
 * This is our small helper to ensure, that always the newes vid gets edited.
 * The normal node API would edit the vid which is currently in {node} table,
 * But we want to edit the VID which is the most recent one.
 */
function _content_moderation_node_edit_page($node) {

  if (variable_get('content_moderation_moderate_latest_only', 1) === 1) {
    $moderated_revs = _content_moderation_has_moderated_revisions($node->nid);

    // Do not allow state changing of revisions, which are not the latest
    // TODO: Maybe we need a exception for the live state to unapprove it later?
    if (count($moderated_revs) > 0) {
      $none_state = content_moderation_none_state();
      drupal_set_message(t('You cannot edit the document, as the latest revision is under moderation. Set the revision back to the state "!state" to be able to edit.', array('!state' => $none_state)), 'warning');
      drupal_goto("node/{$node->nid}");
      return false;
    }
  }
  if (content_moderation_node_type_moderated($node->type)) {
    $vid =  _content_moderation_latest_revision($node->nid);
    // Drupal uses the vid of the node table, not the real latest revision out of node_revision
    // so we need to determine if it differes. If yes, load the latst revision, as thats our last pending one.

    if ($node->vid != $vid) {
      // We only need to change the behavior if the current version is not the latest pending version.
      $node = node_load($node->nid, $vid);
    }
  }
  return node_page_edit($node);
}

/*
 * Fetch the revision data without using node_load to save some performance.
 */
function _content_moderation_revision_infos($vid) {
  $result = db_query('SELECT * FROM {node_revision} WHERE vid=%d', $vid);
  return db_fetch_object($result);
}

/*
 * Calculated the most recent vid of the current node
 */
function _content_moderation_latest_revision($nid) {
  return db_query('SELECT MAX(vid) FROM {node_revision} WHERE nid = :nid', array(':nid' => $nid))->fetchField();
}

/**
 * Generating a history overview of a node.
 *
 * @param $node
 *   Object, Drupal node object
 */
function content_moderation_history($node) {
  drupal_add_css(drupal_get_path('module', 'content_moderation') . '/css/content_moderation_history.css');
  $history = _content_moderation_get_history(array('name' => 'nid', 'value' => $node->nid));
  drupal_set_title(t('History'));
  return theme('content_moderation_node_history', array('history' => $history, 'node' => $node));
}

/**
 * Returning the node object of the live version of the node
 *
 * @param $nid
 *   Int, Drupal node id
 * @return $node
 *   Object, Drupal node if we found one, otherwise false
 */
function _content_moderation_live_revision($nid) {
  $result = db_query("SELECT vid FROM {content_moderation_node_history}
    WHERE nid = :nid
    AND state_name = :state_name
    ORDER BY hid
    DESC LIMIT 1",
    array(
      ':nid' => $nid,
      ':state_name' => content_moderation_live_state()
  ));

  // Did we get a VID back?
  foreach ($result as $vid) {
    return node_load($nid, $vid);
  }

}

/**
 * Returns the key which represents the live version.
 * Should be later an interface to change the live state
 */
function content_moderation_live_state() {
  return 'live';
}


/**
 * Returns the key which represents the neutral non moderated version.
 * Should be later an interface to change the live state
 */
function content_moderation_none_state() {
  return 'none';
}



/**
 * Getting nid by vid
 */
function _content_moderation_get_nid($vid) {
  return db_query('SELECT nid FROM {node_revision} WHERE vid = :vid', array(':vid' => $vid))->fetchField();
}

/*
 * Return the proper path to the change-state action
 */
function _content_moderation_change_state_link($vid, $nid) {
  return "moderate/$nid/$vid/change";
}

/**
 * Checking, if the user has the proper rights to change the state of a node, so
 * checking the transition and node type.
 */
function _content_moderation_state_allowed($user, $from_state, $to_state, $node_type) {
  return user_access("moderate $node_type state $from_state to $to_state");
}

/*
 * Provides a hook where modules can register there access handler.
 * Example:
 *
 * function mymodul_content_moderation_access($op,$node) {
 *  switch($op) {
 *    case 'view history':
 *      return node_acces($op,$node)
 *    break;
 *  }
 * }
 */
function _content_moderation_access($op, $node) {
  if (content_moderation_node_type_moderated($node->type) === false) {
    return false;
  }

  $modules = module_implements('content_moderation_access');
  if (count($modules) > 0) {
    $grants = module_invoke_all('content_moderation_access', $op, $node);
    $result = true;
    foreach ($grants as $bool) {
      $return = $return && $bool;
    }
    return $result;
  }

  //else the default
  switch ($op) {
    case 'view history':
      return content_moderation_node_type_moderated($node->type) && user_access("view {$node->type} moderation history");
      break;
    case 'view revision':
      return node_access('view', $node);
      break;
  }
}

/**
 * Get a number of latest revisions of a node.
 * Use 0 for limit if you want all the revisions
 */
function _content_moderation_get_latest_revisions($nid, $limit = 5, $vid = NULL, $exclude = array()) {
  if ($vid == NULL) {
    // Can we find a node revision for this node?
    if (! $live = _content_moderation_live_revision($nid)) {
      // No live revision
      $vid = NULL;
    }
  }


  if ($limit != 0) {
    $limit = " limit $limit";
  }
  else {
    // limit is zero, so dont use one
    $limit = '';
  }

  $filter = array();
  foreach ($exclude as $v) {
    $filter[] = "nr.vid <> $v";
  }
  if (count($filter) > 0) {
    $filter = join(' AND ', $filter);
    $filter = ' AND ' . $filter;
  }
  else {
    $filter = '';
  }
  // TODO: important, most probably use db_rewrite_sql here
  // if vid is still null, we actually dont have a live revision. So we need to count all revisions, even that one
  // which is currently references in the node table.
  if (! $vid) {
    $results = db_query("SELECT nr.*, cmrs.state_name
      FROM {node_revision} AS nr
      LEFT JOIN {content_moderation_revision_state} AS cmrs
        ON nr.vid = cmrs.vid
      WHERE nr.nid = :nid {$filter}
      ORDER BY nr.vid
      DESC $limit", array(':nid' => $nid));
  }
  else {
    $results = db_query("SELECT nr.*, cmrs.state_name
      FROM {node_revision} AS nr
      LEFT JOIN {content_moderation_revision_state} AS cmrs
        ON nr.vid = cmrs.vid
      WHERE nr.nid=%d
      AND nr.vid > %d {$filter}
      ORDER BY nr.vid
      DESC $limit", $nid, $vid);
  }

  $revs = array();
  foreach($results as $revision) {
    $revs[] = $revision;
  }

  return $revs;
}

function _content_moderation_get_current_viewed_node() {
  // Get the URL information
  $router_item = menu_get_item();

  // Is this a node page?
  if ($router_item['original_map'][0] != 'node') {
    return NULL;
  }

  // Get the node from the node id
  if (! $node = node_load($router_item['original_map'][1])) {
    return NULL;
  }

  // Can we get a changed
  if (isset($router_item['original_map'][2]) && is_numeric($router_item['original_map'][2])) {
    if (isset($router_item['original_map'][3]) && $router_item['original_map'][3] == 'view') {
      $vid = $router_item['original_map'][2];
      $node = node_load(array('nid' => $node->nid, 'vid' => $vid));
    }
  }

  return $node;
}

/**
 * Small helper for trigger and rules
 */
function _content_moderation_node_transition_matrix() {
  static $node_state_matrix = array();
  // chaching
  if (count($node_state_matrix) > 0) {
    return $node_state_matrix;
  }
  $states = content_moderation_states();
  $types = content_moderation_node_types();
  foreach ($types as $type) {
    foreach ($states as $from_state) {
     // $to_states = _content_moderation_next_states($from_state, $type);
      // Values are translated.
      $to_states = array_keys($to_states);
      foreach ($to_states as $to_state) {
        $node_state_matrix["{$type}_{$from_state}_{$to_state}"] = t("State of node type @type changed from '@from_state' to '@to_state'", array('@type' => $type, '@from_state' => $from_state, '@to_state' => $to_state));
      }
    }
  }
  return $node_state_matrix;
}

/**
 * Checks if the current version is the currently shown as live
 * without beeing approved before (current vid in the {node} table
 */
function _content_moderation_is_not_approved_live($vid) {
  $result = db_query('SELECT count(vid) FROM {node} where vid=%d limit 1', $vid)->fetchField();
  if ($result > 0) {
    return true;
  }
  // else
  return false;
}

function _content_moderation_get_current_title($nid) {
  return db_query('SELECT title from {node} where nid=%d', $nid)->fetchField();
}

function _content_moderation_show_latest_revision($node) {
  $revisions = _content_moderation_get_latest_revisions($node->nid, 1);
  $node = node_load($node->nid, $revisions[0]->vid);
  menu_set_active_item("node/{$node->nid}/revisions/{$node->vid}/view");
  return node_page_view($node);
}

function _content_moderation_has_moderated_revisions($nid) {
  $none_state = content_moderation_none_state();
  $live_state = content_moderation_live_state();
  // Get all revisions which are neither in the none nor in the live state
  $results = db_query("SELECT nr.*, cmrs.state_name
    FROM {node_revision} nr
    LEFT JOIN {content_moderation_revision_state} cmrs
    ON nr.vid = cmrs.vid
    WHERE nr.nid = :nid
      AND cmrs.state_name <> :none_state
      AND cmrs.state_name <> :live_state", array(
        ':nid' => $nid,
        ':none_state' => $none_state,
        ':live_state' => $live_state
      ));

  $revisions = array();
  foreach ($results as $revision) {
    $revisions[] = $revision;
  }

  return $revisions;
}

/*
 * Helper to ensure, that 'Create new revision is always checked', when a node type is selected to be moderated
 */
function _content_moderation_validate_node_type_form($from, &$form_state) {
  if ($form_state['values']['node_options']['node_content_moderation'] === 'node_content_moderation' && $form_state['values']['node_options']['revision'] === 0) {
    form_set_error('node_options', t('If you chose to moderate this content type, you must switch "Create new revision" in the workflow tab on'));
  }
}

/*
 * Redirects to the new created revisions
 */
function _content_moderation_submit_node_form($form, &$form_state) {
  $nid = $form['nid']['#value'];
  $form_state['redirect'] = "node/$nid/latest_revision";
}

function _content_moderation_latest_live_in_history($nid) {
  $result = _content_moderation_get_history(array('name' => 'nid', 'value' => $nid), 'live');
  if (is_array($result) && count($result) > 0) {
    return $result[0];
  }
  // else
  return false;
}

function _content_moderation_latest_entry_in_history($vid, $state = 'live' ) {
  $result = _content_moderation_get_history(array('name' => 'vid', 'value' => $vid), $state);
  if (is_array($result) && count($result) > 0) {
    return $result[0];
  }
  // else
  return false;
}


/**
 * Displays the content moderation block
 *
 * @return boolean
 */
function content_moderation_block_moderation_info() {
    // Can we find a current node?
    if (! $node = _content_moderation_get_current_viewed_node()) {
      return;
    }
    
    // Do not show the block if the node is not moderated
    if (! content_moderation_node_type_moderated($node->type)) {
      return;
    }

    // Make sure we have all the node history
    content_moderation_node_history($node);

    $arguments['node'] = $node;

    // Add the CSS for the block
    drupal_add_css(drupal_get_path('module', 'content_moderation') . '/css/content_moderation_block.css');

    // Build the icons
    $edit_icon = '<span class="tinyicon t_editicon"></span>';
    $rev_icon = '<span class="tinyicon t_revisionicon"></span>';
    $edit_state_icon = '<span class="tinyicon t_changestateicon"></span>';
    $delete_icon = '<span class="tinyicon t_deleteicon"></span>';
    $view_icon = '<span class="tinyicon t_viewicon"></span>';


    // @HERE
    
    // Get a themed list of revisions
    $revisions_list = theme('content_moderation_revisions_list', array('node' => $node));

   

    // Is this version of the node the live one?
    if ($node->content_moderation['current'] == content_moderation_live_state()) {
      $arguments['live'] = $live;
      $arguments['edit_live'] = "node/{$node->nid}/edit";
      $arguments['compare'] = "node/{$node->nid}/revisions";
      $arguments['live_view'] = 'node/' . $live->nid;
      $arguments['edit_state'] = l($edit_state_icon, 'node/' . $live->nid, array(
        'html' => true,
        'attributes' => array(
          'title' => t('Edit the state of this revision.')
        )
      ));
      $arguments['live_view'] = l($view_icon, 'node/' . $live->nid, array(
        'html' => true,
        'attributes' => array(
          'title' => t('View live revision')
        )
      ));
    }

    else {
      $arguments['edit_state'] = l(t('Change state'), _content_moderation_change_state_link($node->vid, $node->nid));
    }


    // @TODO handle access concerns here
    $arguments['delete_current'] = l($delete_icon, $node->vid, array(
      'html' => true,
      'attributes' => array(
        'title' => t('Delete this revision')
      )
    ));

    // Is there more than one version to compare to?
    isset($live->vid) ? $arguments['compare_with_live'] = "node/{$node->nid}/revisions/view/{$node->vid}/{$live->vid}" : NULL;

    // Get the state of the currently view revision
 //    $state = ucfirst(_content_moderation_current_state($node->vid));


    $arguments['view_current_link'] = l($view_icon, "node/{$node->nid}/revisions/{$node->vid}/view", array(
      'html' => true,
      'attributes' => array(
        'title' => t('View this revision.')
       )
    ));


    $arguments['current_rev_link'] = l($node->vid, "node/{$node->nid}/revisions/{$node->vid}/view", array(
      'html' => true,
      'attributes' => array(
        'title' => t('View this revision.')
      )
    ));

    if (module_exists('diff')) {
      $arguments['compare_live'] = l($rev_icon, $arguments['compare_with_live'], array(
        'html' => true,
        'attributes' => array(
          'title' => t('Compare this revision with the live revision.')
         )
      ));
      $arguments['compare'] = l($rev_icon, $arguments['compare'], array(
        'html' => true,
        'attributes' => array(
          'title' => t('List all revisions.')
        )
      ));
    }

  $arguments['account'] = user_load($node->revision_uid);

  $block['subject'] = t("Revisions");
  $block['content'] = theme('content_moderation_info_block', array('arguments' => $arguments));

  $block['cache'] = false;
  return $block;
}


/**
 * Utility function to fetch node history for specified node
 *
 * @param $node
 */
function content_moderation_node_history(&$node) {
  // Find any state changes
  $results = db_query("SELECT * FROM {content_moderation_node_history}
    WHERE nid = :nid
    ORDER BY hid DESC",
    array(':nid' => $node->nid)
  );

  $node->content_moderation = array();
  foreach ($results as $result) {
    $node->content_moderation['nodes'][$result->hid] = $result;
  }

  // Now we need to get the current state of the node
  $result = db_query("SELECT state_name FROM {content_moderation_revision_state} WHERE nid = :nid AND vid = :vid",
    array(':nid' => $node->nid, ':vid' => $node->vid)
  )->fetchField();
  if (! $result) {
    $state_name = content_moderation_none_state();
  }
  else {
    $state_name = $result;
  }
  $node->content_moderation['current'] = $state_name;

}


/**
 * Utility fuction get all existing states
 */
function content_moderation_states() {
  static $states = FALSE;
  if (! $states) {
    $results = db_query("SELECT * FROM {content_moderation_states}");
    $states = array();
    foreach($results as $state) {
      $states[$state->name] = $state->descr ? $state->descr : $state->name;
    }
  }
  return $states;
}


/**
 * Utility function to get all existing transitions
 *
 * @return
 *   Array of transitions
 */
function content_moderation_transitions() {
  static $transitions = FALSE;
  if (! $transitions) {
    $results = db_query("SELECT * FROM {content_moderation_transition}");
    $transitions = array();
    foreach ($results as $transition) {
      $transinfo = $transition->from_name . '---' . $transition->to_name;
      $transitions[$transinfo] = $transition->from_name . ' -> ' . $transition->to_name;
    }
  }
  return $transitions;
}


/**
 * Utility fuction get all existing transitions
 *
 * @param $state_transition_from
 *   Optional, return steps that can be transitioned too from this specified step
 */
function content_moderation_transitions_map($state_transition_from = FALSE) {
  static $states = FALSE;
  if (! $states) {
    $results = db_query("SELECT * FROM {content_moderation_transition}");
    $states = array();
    foreach($results as $state) {
      $states[$state->from_name][] = $state->to_name;
    }
  }

  // Do we need to return only the steps that can be done from this step
  if ($state_transition_from) {
    // Make sure that this a valid transition
    if (! isset($states[$state_transition_from])) {
      return $states[content_moderation_none_state()];
    }
    return $states[$state_transition_from];
  }
  return $states;
}


/**
 * Utility function to build
 */

/**
 * Utility function to check if this node type is moderated
 *
 * @return
 *   Boolean
 */
function content_moderation_node_type_moderated($type) {
  // Is this content type moderated?
  $var = variable_get("node_options_$type", array(0));
  if (in_array('node_content_moderation', $var) ) {
    return true;
  }
  return false;
}


/**
 * Utility function to get all the moderated node types
 */
function content_moderation_node_types() {
  static $result = FALSE;

  if (! $result) {
    $types = node_type_get_types();
    $result = array();
    foreach ($types as $type) {
      // Is this content even in moderatation?
      if ( content_moderation_node_type_moderated($type->type)) {
        $result[] = $type->type;
      }
    }
  }

  return $result;
}


/**
 * Display node history
 *
 * Theming the output of content moderations history table
 *
 * @param $history
 *  Array
 */
function theme_content_moderation_node_history($variables) {
  $title = t('!title: moderation history', array('!title' => $variables['node']->title));
  $title = "<h2>$title</h2>";

  if (! $variables['history']) {
    return t('No revisions exists yet');
  }

  $data = array();
  foreach ($variables['revisions'] as $revision) {
    $user = user_load_multiple($revision->uid);
    $state_class = "state_{$revision->state_name}";
    $data[] = array(
      format_date($revision->stamp, 'short'),
      // User who changed the state
      l($user->name, 'user/{$user->uid}'),
      // State change
      "<span class='$state_class'>" .
        ucfirst(t('!old', array('!old' => $e->old_state_name))) . ' -> ' .
        ucfirst(t($e->state_name)) .
      '</span>',
      l($e->vid, "node/{$e->nid}/revisions/{$e->vid}/view"),    // revision
      check_plain($e->comment), // comment
    );
  }


  return $title . theme('table', array('header' =>
    array(
      t('Date'),
      t('Author'),
      t('Transition'),
      t('Revision'),
      t('Comment'),
    )
    , 'rows' => $data));
}
